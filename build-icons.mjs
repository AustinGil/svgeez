import { promises as fs, watch } from "node:fs"
import * as path from "node:path"
import { glob } from "glob"
import { parse } from "node-html-parser"
import { optimize } from 'svgo'

const cwd = process.cwd()
const inputDir = path.join(cwd, "src/svg-icons")
const inputDirRelative = path.relative(cwd, inputDir)

// const outputDir = path.join(
//   cwd,
//   "src",
//   "components",
//   "icons",
// )
// const outputDirRelative = path.relative(cwd, outputDir)
async function runner() {
  const files = glob
    .sync("**/*.svg", {
      cwd: inputDir,
      ignore: "sprite.svg"
    })

  if (files.length === 0) {
    console.log(`No SVG files found in ${inputDirRelative}`)
    process.exit(0);
  }
  // The relative paths are just for cleaner logs
  // console.log(`Generating sprite for ${inputDirRelative}`)

  const spritesheetContent = await generateSvgSprite({
    files,
    inputDir,
  })

  const result = optimize(spritesheetContent, {
    plugins: [
      {
        name: 'preset-default',
        params: {
          overrides: {
            removeHiddenElems: false,
          }
        }
      }
    ]
  });
  const optimizedSvgString = result.data;

  await writeIfChanged(
    path.join(inputDir, "sprite.svg"),
    optimizedSvgString,
  )
  /**
   * Outputs an SVG string with all the icons as symbols
   * 
   * @param {{
   * files: string[]
   * inputDir: string
   * }} param0 
   */
  async function generateSvgSprite({
    files,
    inputDir,
  }) {
    // Each SVG becomes a symbol and we wrap them all in a single SVG
    const symbols = await Promise.all(
      files.map(async (file) => {
        const input = await fs.readFile(
          path.join(inputDir, file),
          "utf8",
        )
        const root = parse(input)
        const svg = root.querySelector("svg")
        if (!svg) throw new Error("No SVG element found")
        svg.tagName = "symbol"
        svg.setAttribute("id", file.replace(/\.svg$/, ""))
        svg.removeAttribute("xmlns")
        svg.removeAttribute("xmlns:xlink")
        svg.removeAttribute("version")
        svg.removeAttribute("width")
        svg.removeAttribute("height")
        return svg.toString().trim()
      }),
    )
    return [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
      `<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
      ...symbols,
      `</defs>`,
      `</svg>`,
    ].join("\n")
  }

  const typesContent = await generateTypes({
    names: files.map((file) => JSON.stringify(file.replace(/\.svg$/, ""))),
  })
  await writeIfChanged(
    path.join(inputDir, "names.ts"),
    typesContent,
  )
  /**
   * @param {{
   * names: string[]
   * }} param0 
   */
  async function generateTypes({
    names,
  }) {
    return [
      `// This file is generated by npm run build:icons`,
      "",
      `export type IconName =`,
      ...names.map((name) => `\t| ${name}`),
      "",
    ].join("\n")
  }

  /**
   * Each write can trigger dev server reloads
   * so only write if the content has changed
   * 
   * @param {string} filepath
   * @param {string} newContent 
   */
  async function writeIfChanged(filepath, newContent) {
    const currentContent = await fs.readFile(filepath, "utf8")
    if (currentContent !== newContent) {
      return fs.writeFile(filepath, newContent, "utf8")
    }
  }
}
runner()

watch(inputDir, {
  recursive: true,
}, (eventType, filename) => {
  runner()
})